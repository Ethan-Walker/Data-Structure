//destroy(Node<T> *&subtree)               删除根结点为subtee的树，
//Parent(Node<T> *subtree,Node<T> *current)得到给定结点current的父结点，
//Traverse(Node<T> *subtree,ostream  &os)  从根结点subtree开始前序遍历输出二叉树
//operator>><<                             运算符重载只能写在含类的头文件里
//CreateBinaryTree(istream&is,Node<char> *&BT) 输入广义表形式创建二叉树
//递归遍历
//前序遍历preorder,中序遍历inorder，后序遍历postorder
//Height(Node<T> *subtree); 得到根结点为subtree的树的高度
//Size (Node<T> *subtree);  得到根结点为subtree的树中结点数目
//Node<T>* Copy(Node<T> *orignode); 复制根结点为orignode的二叉树
//  int operator==(const BinaryTree<T> &s,const BinaryTree<T> &t);  //判断两个树是否相等
//    bool Equal(Node<T>> *a,Node<T> *b);
//CreateBinaryTree(ifstream&is,Node<T> *&subtree)利用前序遍历 以递归方式建立二叉树
//PrintBTree(Node<T> *BT) 以广义表的形式输出二叉树

//LevelOrder  按层次序遍历输出二叉树




